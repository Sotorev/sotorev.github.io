---
export interface Props {
	src: string;
	alt: string;
	width?: number;
	height?: number;
	gridSize?: number;
}

const { src, alt, width = 200, height = 200, gridSize = 16 } = Astro.props;
---

<div class="image-container" style={`width: ${width}px; height: ${height}px;`}>
	<img {src} {alt} class="hero-image" id="sourceImage" />
	<canvas id="pixelCanvas"></canvas>
</div>

<style>
	.image-container {
		position: relative;
		/* border-radius: clamp(10px, 2vw, 20px); */
		box-shadow: 0 clamp(10px, 3vw, 20px) clamp(30px, 8vw, 60px) rgba(0, 0, 0, 0.5);
		overflow: hidden;
		flex-shrink: 0;
		align-self: flex-start;
	}

	.hero-image {
		width: 100%;
		height: 100%;
		object-fit: cover;
		opacity: 0;
		position: absolute;
		z-index: 1;
	}

	#pixelCanvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 2;
		cursor: pointer;
	}

	@media (max-width: 768px) {
		.image-container {
			width: clamp(120px, 30vw, 160px) !important;
			height: clamp(120px, 30vw, 160px) !important;
		}
	}

	@media (max-width: 480px) {
		.image-container {
			width: clamp(100px, 35vw, 140px) !important;
			height: clamp(100px, 35vw, 140px) !important;
		}
	}
</style>

<script define:vars={{ gridSize }}>
	class PixelatedCanvas {
		constructor(container, sourceImage, canvas, gridSize) {
			this.container = container;
			this.sourceImage = sourceImage;
			this.canvas = canvas;
			this.ctx = canvas.getContext('2d');
			this.gridSize = gridSize;
			this.pixelData = [];
			this.originalPixelData = [];
			this.hoveredPixel = null;
			this.animationFrame = null;
			
			this.init();
		}

		init() {
			this.resizeCanvas();
			this.addEventListeners();
			
			if (this.sourceImage.complete) {
				this.processImage();
			} else {
				this.sourceImage.onload = () => this.processImage();
			}
		}

		resizeCanvas() {
			const rect = this.container.getBoundingClientRect();
			this.canvas.width = rect.width;
			this.canvas.height = rect.height;
			this.pixelSize = Math.floor(Math.min(rect.width, rect.height) / this.gridSize);
			this.actualGridWidth = Math.floor(rect.width / this.pixelSize);
			this.actualGridHeight = Math.floor(rect.height / this.pixelSize);
		}

		processImage() {
			// Create a temporary canvas to sample the image
			const tempCanvas = document.createElement('canvas');
			const tempCtx = tempCanvas.getContext('2d');
			tempCanvas.width = this.canvas.width;
			tempCanvas.height = this.canvas.height;
			
			// Draw the source image to temp canvas
			tempCtx.drawImage(this.sourceImage, 0, 0, tempCanvas.width, tempCanvas.height);
			
			// Sample pixels and store data
			this.pixelData = [];
			this.originalPixelData = [];
			
			for (let y = 0; y < this.actualGridHeight; y++) {
				for (let x = 0; x < this.actualGridWidth; x++) {
					const sampleX = x * this.pixelSize + this.pixelSize / 2;
					const sampleY = y * this.pixelSize + this.pixelSize / 2;
					
					const imageData = tempCtx.getImageData(sampleX, sampleY, 1, 1);
					const [r, g, b] = imageData.data;
					
					// Convert to grayscale
					const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
					
					const pixelInfo = {
						x,
						y,
						originalR: r,
						originalG: g,
						originalB: b,
						gray,
						currentR: gray,
						currentG: gray,
						currentB: gray
					};
					
					this.pixelData.push(pixelInfo);
					this.originalPixelData.push({ ...pixelInfo });
				}
			}
			
			this.render();
		}

		render() {
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
			
			for (const pixel of this.pixelData) {
				this.ctx.fillStyle = `rgb(${pixel.currentR}, ${pixel.currentG}, ${pixel.currentB})`;
				this.ctx.fillRect(
					pixel.x * this.pixelSize,
					pixel.y * this.pixelSize,
					this.pixelSize - 1,
					this.pixelSize - 1
				);
			}
		}

		getPixelFromCoords(mouseX, mouseY) {
			const rect = this.canvas.getBoundingClientRect();
			const x = Math.floor((mouseX - rect.left) / this.pixelSize);
			const y = Math.floor((mouseY - rect.top) / this.pixelSize);
			
			if (x >= 0 && x < this.actualGridWidth && y >= 0 && y < this.actualGridHeight) {
				return this.pixelData.find(p => p.x === x && p.y === y);
			}
			return null;
		}

		getNeighbors(targetPixel) {
			const neighbors = [];
			const { x, y } = targetPixel;
			
			for (let dy = -1; dy <= 1; dy++) {
				for (let dx = -1; dx <= 1; dx++) {
					const nx = x + dx;
					const ny = y + dy;
					
					if (nx >= 0 && nx < this.actualGridWidth && 
						ny >= 0 && ny < this.actualGridHeight && 
						!(dx === 0 && dy === 0)) {
						
						const neighbor = this.pixelData.find(p => p.x === nx && p.y === ny);
						if (neighbor) {
							neighbors.push(neighbor);
						}
					}
				}
			}
			
			return neighbors;
		}

		animateColors() {
			if (!this.hoveredPixel) return;
			
			const neighbors = this.getNeighbors(this.hoveredPixel);
			
			// Set hovered pixel to white
			this.hoveredPixel.currentR = 255;
			this.hoveredPixel.currentG = 255;
			this.hoveredPixel.currentB = 255;
			
			// Collect original colors from all neighbors
			const originalColors = neighbors.map(neighbor => ({
				r: neighbor.originalR,
				g: neighbor.originalG,
				b: neighbor.originalB
			}));
			
			// Shuffle the colors array randomly
			const shuffledColors = [...originalColors].sort(() => Math.random() - 0.5);
			
			// Assign shuffled colors to neighbors
			neighbors.forEach((neighbor, index) => {
				const shuffledColor = shuffledColors[index];
				neighbor.currentR = shuffledColor.r;
				neighbor.currentG = shuffledColor.g;
				neighbor.currentB = shuffledColor.b;
			});
			
			this.render();
			
			this.animationFrame = requestAnimationFrame(() => {
				setTimeout(() => this.animateColors(), 300); // Increased from 100ms to 300ms for slower animation
			});
		}

		resetPixelColors() {
			for (const pixel of this.pixelData) {
				pixel.currentR = pixel.gray;
				pixel.currentG = pixel.gray;
				pixel.currentB = pixel.gray;
			}
			this.render();
		}

		addEventListeners() {
			this.canvas.addEventListener('mousemove', (e) => {
				const pixel = this.getPixelFromCoords(e.clientX, e.clientY);
				
				if (pixel !== this.hoveredPixel) {
					if (this.animationFrame) {
						cancelAnimationFrame(this.animationFrame);
						this.animationFrame = null;
					}
					
					this.resetPixelColors();
					this.hoveredPixel = pixel;
					
					if (this.hoveredPixel) {
						this.animateColors();
					}
				}
			});
			
			this.canvas.addEventListener('mouseleave', () => {
				if (this.animationFrame) {
					cancelAnimationFrame(this.animationFrame);
					this.animationFrame = null;
				}
				
				this.hoveredPixel = null;
				this.resetPixelColors();
			});
			
			window.addEventListener('resize', () => {
				setTimeout(() => {
					this.resizeCanvas();
					this.processImage();
				}, 100);
			});
		}
	}

	// Initialize the pixelated canvas
	const container = document.querySelector('.image-container');
	const sourceImage = document.getElementById('sourceImage');
	const canvas = document.getElementById('pixelCanvas');

	if (container && sourceImage && canvas) {
		new PixelatedCanvas(container, sourceImage, canvas, gridSize);
	}
</script> 
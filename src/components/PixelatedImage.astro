---
export interface Props {
	src: string;
	alt: string;
}

const { src, alt } = Astro.props;
---

<div class="image-container">
	<img {src} {alt} class="hero-image" id="sourceImage" />
	<canvas id="pixelCanvas"></canvas>
	<div class="pixel-grid" id="pixelGrid"></div>
</div>

<style>
	.image-container {
		position: relative;
		width: clamp(150px, 25vw, 200px);
		height: clamp(150px, 25vw, 200px);
		border-radius: clamp(10px, 2vw, 20px);
		box-shadow: 0 clamp(10px, 3vw, 20px) clamp(30px, 8vw, 60px) rgba(0, 0, 0, 0.5);
		overflow: hidden;
		flex-shrink: 0;
		align-self: flex-start;
	}

	.hero-image {
		width: 100%;
		height: 100%;
		object-fit: cover;
		opacity: 0;
		position: absolute;
		z-index: 1;
	}

	#pixelCanvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 2;
		opacity: 0;
	}

	.pixel-grid {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 3;
		display: grid;
		gap: 1px;
	}

	.pixel {
		background-color: #333;
		transition: all 0.2s ease;
		border-radius: 1px;
		position: relative;
		overflow: hidden;
	}

	@media (max-width: 768px) {
		.image-container {
			width: clamp(120px, 30vw, 160px);
			height: clamp(120px, 30vw, 160px);
		}
	}

	@media (max-width: 480px) {
		.image-container {
			width: clamp(100px, 35vw, 140px);
			height: clamp(100px, 35vw, 140px);
		}
	}
</style>

<script>
	const container = document.querySelector('.image-container') as HTMLElement;
	const sourceImage = document.getElementById('sourceImage') as HTMLImageElement;
	const canvas = document.getElementById('pixelCanvas') as HTMLCanvasElement;
	const pixelGrid = document.getElementById('pixelGrid') as HTMLElement;

	let pixelSize = 12;
	let gridWidth = 16;
	let gridHeight = 16;
	let pixels: HTMLElement[] = [];
	let animationIntervals: Map<string, any> = new Map();

	function updateGridSize(): void {
		const containerWidth = container.offsetWidth;
		const containerHeight = container.offsetHeight;
		
		// Adjust grid based on container size
		if (containerWidth < 140) {
			pixelSize = 8;
			gridWidth = Math.floor(containerWidth / pixelSize);
			gridHeight = Math.floor(containerHeight / pixelSize);
		} else if (containerWidth < 180) {
			pixelSize = 10;
			gridWidth = Math.floor(containerWidth / pixelSize);
			gridHeight = Math.floor(containerHeight / pixelSize);
		} else {
			pixelSize = 12;
			gridWidth = 16;
			gridHeight = 16;
		}
	}

	function getNeighbors(x: number, y: number): { x: number; y: number; distance: number }[] {
		const neighbors: { x: number; y: number; distance: number }[] = [];

		for (let dy = -1; dy <= 1; dy++) {
			for (let dx = -1; dx <= 1; dx++) {
				const nx = x + dx;
				const ny = y + dy;

				if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight && !(dx === 0 && dy === 0)) {
					const distance = Math.sqrt(dx * dx + dy * dy);
					neighbors.push({ x: nx, y: ny, distance });
				}
			}
		}

		return neighbors;
	}

	function addHoverEffect(pixel: HTMLElement, x: number, y: number): void {
		let isHovering = false;

		pixel.addEventListener('mouseenter', () => {
			isHovering = true;
			const neighbors = getNeighbors(x, y);
			const animationKey = `${x}-${y}`;

			pixel.style.backgroundColor = 'rgb(255, 255, 255)';

			const neighborColors = neighbors.map(({ x: nx, y: ny }) => {
				const neighborPixel = pixels[ny * gridWidth + nx];
				return neighborPixel.dataset.originalColor || 'rgb(128, 128, 128)';
			});

			if (animationIntervals.has(animationKey)) {
				window.clearInterval(animationIntervals.get(animationKey)!);
			}

			const animateNeighbors = () => {
				const shuffledColors = [...neighborColors].sort(() => Math.random() - 0.5);

				neighbors.forEach(({ x: nx, y: ny }, index) => {
					const neighborPixel = pixels[ny * gridWidth + nx];
					if (neighborPixel) {
						neighborPixel.style.backgroundColor = shuffledColors[index];
					}
				});
			};

			animateNeighbors();

			const interval = window.setInterval(() => {
				if (!isHovering) {
					window.clearInterval(interval);
					animationIntervals.delete(animationKey);
					return;
				}

				animateNeighbors();
			}, 100);

			animationIntervals.set(animationKey, interval);
		});

		pixel.addEventListener('mouseleave', () => {
			isHovering = false;
			const neighbors = getNeighbors(x, y);

			const originalGray = pixel.dataset.originalGray || '128';
			pixel.style.backgroundColor = `rgb(${originalGray}, ${originalGray}, ${originalGray})`;

			neighbors.forEach(({ x: nx, y: ny }) => {
				const neighborPixel = pixels[ny * gridWidth + nx];
				if (!neighborPixel) return;

				const originalGray = neighborPixel.dataset.originalGray || '128';
				neighborPixel.style.backgroundColor = `rgb(${originalGray}, ${originalGray}, ${originalGray})`;
			});
		});
	}

	function initializePixelGrid(): void {
		if (!sourceImage || !canvas || !pixelGrid || !container) return;

		updateGridSize();

		canvas.width = container.offsetWidth;
		canvas.height = container.offsetHeight;
		const ctx = canvas.getContext('2d');
		if (!ctx) return;

		pixelGrid.style.gridTemplateColumns = `repeat(${gridWidth}, 1fr)`;
		pixelGrid.style.gridTemplateRows = `repeat(${gridHeight}, 1fr)`;

		sourceImage.onload = () => {
			ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);
			createPixelGrid(ctx);
		};

		if (sourceImage.complete) {
			ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);
			createPixelGrid(ctx);
		}
	}

	function createPixelGrid(ctx: CanvasRenderingContext2D): void {
		pixelGrid.innerHTML = '';
		pixels = [];

		for (let y = 0; y < gridHeight; y++) {
			for (let x = 0; x < gridWidth; x++) {
				const pixel = document.createElement('div');
				pixel.className = 'pixel';

				const sampleX = x * pixelSize + pixelSize / 2;
				const sampleY = y * pixelSize + pixelSize / 2;
				const imageData = ctx.getImageData(sampleX, sampleY, 1, 1);
				const [r, g, b] = imageData.data;

				pixel.dataset.originalR = r.toString();
				pixel.dataset.originalG = g.toString();
				pixel.dataset.originalB = b.toString();
				pixel.dataset.originalColor = `rgb(${r}, ${g}, ${b})`;

				const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
				pixel.style.backgroundColor = `rgb(${gray}, ${gray}, ${gray})`;

				pixel.dataset.originalGray = gray.toString();
				pixel.dataset.x = x.toString();
				pixel.dataset.y = y.toString();
				pixel.dataset.index = (y * gridWidth + x).toString();

				addHoverEffect(pixel, x, y);

				pixelGrid.appendChild(pixel);
				pixels.push(pixel);
			}
		}
	}

	// Handle resize events
	function handleResize(): void {
		setTimeout(() => {
			initializePixelGrid();
		}, 100);
	}

	window.addEventListener('resize', handleResize);

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initializePixelGrid);
	} else {
		initializePixelGrid();
	}
</script> 